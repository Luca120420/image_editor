if (currentTool !== 'text') {
                    const size = parseInt(document.getElementById('brushSize').value);
                    brushCursor.style.width = size + 'px';
                    brushCursor.style.height = size + 'px';
                    
                    brushCursor.style.left = (e.pageX - size/2) + 'px';
                    brushCursor.style.top = (e.pageY - size/2) + 'px';
                    brushCursor.style.display = 'block';
                } else {
                    brushCursor.style.display = 'none';
                }
            });

            canvas.addEventListener('mouseleave', function() {
                brushCursor.style.display = 'none';
            });
        }

        function setTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-group button').forEach(btn => btn.classList.remove('active'));
            const toolBtn = document.getElementById(tool + 'Btn');
            if (toolBtn) toolBtn.classList.add('active');
            
            canvas.style.cursor = tool === 'text' ? 'text' : 'crosshair';
            
            if (tool === 'pixelate' && originalImageData) {
                generatePixelatedVersion();
            }
            
            updateStatus(`${tool.charAt(0).toUpperCase() + tool.slice(1)} tool selected`);
        }

        function startDrawing(e) {
            if (e.type === 'touchstart') e.preventDefault();
            
            if (currentTool === 'text' || !originalImageData) return;
            isDrawing = true;
            saveToUndoStack();
            draw(e);
        }

        function draw(e) {
            if (!isDrawing || currentTool === 'text' || !originalImageData) return;

            if (e.type === 'touchmove') e.preventDefault(); 
            
            const coords = getCoords(e);
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (coords.clientX - rect.left) * scaleX;
            const y = (coords.clientY - rect.top) * scaleY;
            const brushSize = parseInt(document.getElementById('brushSize').value);
            const strength = parseInt(document.getElementById('effectStrength').value);

            applyEffect(x, y, brushSize, strength);
        }

        function stopDrawing() {
            isDrawing = false;
            if (brushCursor) brushCursor.style.display = 'none';
        }

        function applyEffect(x, y, size, strength) {
            const halfSize = Math.floor(size / 2);
            const startX = Math.max(0, x - halfSize);
            const startY = Math.max(0, y - halfSize);
            const width = Math.min(size, canvas.width - startX);
            const height = Math.min(size, canvas.height - startY);
            
            if (currentTool === 'pixelate') {
                if (pixelatedImageData) {
                    const startXInt = Math.floor(startX);
                    const startYInt = Math.floor(startY);
                    const widthInt = Math.ceil(width);
                    const heightInt = Math.ceil(height);
                    
                    applyPixelatedBrush(startXInt, startYInt, widthInt, heightInt, x, y, halfSize);
                }
            } else {
                const imageData = ctx.getImageData(startX, startY, width, height);
                
                switch(currentTool) {
                    case 'blur':
                        blurEffect(imageData, Math.max(1, strength/20));
                        break;
                    case 'brighten':
                        brightnessEffect(imageData, strength);
                        break;
                    case 'darken':
                        brightnessEffect(imageData, -strength);
                        break;
                }
                
                ctx.putImageData(imageData, startX, startY);
            }
        }

        function applyPixelatedBrush(startX, startY, width, height, centerX, centerY, radius) {
            const currentImageData = ctx.getImageData(startX, startY, width, height);
            const currentData = currentImageData.data;
            const pixelatedData = pixelatedImageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const actualX = startX + x;
                    const actualY = startY + y;
                    
                    const dx = actualX - centerX;
                    const dy = actualY - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= radius) {
                        const sourceIndex = (actualY * canvas.width + actualX) * 4;
                        const targetIndex = (y * width + x) * 4;
                        
                        if (sourceIndex + 3 < pixelatedData.length) {
                            currentData[targetIndex] = pixelatedData[sourceIndex];
                            currentData[targetIndex + 1] = pixelatedData[sourceIndex + 1];
                            currentData[targetIndex + 2] = pixelatedData[sourceIndex + 2];
                            currentData[targetIndex + 3] = pixelatedData[sourceIndex + 3];
                        }
                    }
                }
            }
            
            ctx.putImageData(currentImageData, startX, startY);
        }

        function blurEffect(imageData, radius) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const copy = new Uint8ClampedArray(data);
            
            radius = Math.max(1, Math.floor(radius));
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0, count = 0;
                    
                    for (let dy = -radius; dy <= radius; dy++) {
                        for (let dx = -radius; dx <= radius; dx++) {
                            const ny = y + dy;
                            const nx = x + dx;
                            
                            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                const index = (ny * width + nx) * 4;
                                r += copy[index];
                                g += copy[index + 1];
                                b += copy[index + 2];
                                a += copy[index + 3];
                                count++;
                            }
                        }
                    }
                    
                    const index = (y * width + x) * 4;
                    data[index] = r / count;
                    data[index + 1] = g / count;
                    data[index + 2] = b / count;
                    data[index + 3] = a / count;
                }
            }
        }

        function brightnessEffect(imageData, adjustment) {
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.max(0, Math.min(255, data[i] + adjustment));
                data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + adjustment));
                data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + adjustment));
            }
        }

        function addTextElement(x, y) {
            const text = document.getElementById('textInput').value || 'Sample Text';
            const textColor = document.getElementById('textColor').value;
            const bgColor = document.getElementById('textBgColor').value;
            const fontSize = parseInt(document.getElementById('fontSize').value);
            const fontFamily = document.getElementById('fontFamily').value;
            const fontBold = document.getElementById('fontBold').checked;
            const fontItalic = document.getElementById('fontItalic').checked;
            
            const textElement = document.createElement('div');
            textElement.className = 'text-overlay';
            textElement.innerHTML = `
                <div class="text-content" contenteditable="true">${text}</div>
                <div class="resize-handle nw"></div>
                <div class="resize-handle ne"></div>
                <div class="resize-handle sw"></div>
                <div class="resize-handle se"></div>
                <div class="rotate-handle"></div>
                <div class="overlay-controls">
                    Size: ${fontSize}px | Rotation: 0° | Press Delete to remove
                </div>
            `;
            
            const containerRelativeLeft = x + CANVAS_CONTAINER_PADDING;
            const containerRelativeTop = y + CANVAS_CONTAINER_PADDING;
            
            textElement.style.position = 'absolute';
            textElement.style.left = containerRelativeLeft + 'px';
            textElement.style.top = containerRelativeTop + 'px';
            textElement.style.color = textColor;
            textElement.style.backgroundColor = bgColor;
            textElement.style.fontSize = fontSize + 'px';
            textElement.style.fontFamily = fontFamily;
            textElement.style.fontWeight = fontBold ? 'bold' : 'normal';
            textElement.style.fontStyle = fontItalic ? 'italic' : 'normal';
            textElement.style.padding = '8px';
            textElement.style.borderRadius = '4px';
            textElement.style.transform = 'rotate(0deg)';
            textElement.style.minWidth = '50px';
            textElement.style.minHeight = '30px';
            textElement.style.lineHeight = '1.2';
            
            const textContent = textElement.querySelector('.text-content');
            textContent.addEventListener('blur', function() {
                updateStatus('Text updated');
            });
            
            setupOverlayEvents(textElement, 'text');
            document.querySelector('.canvas-container').appendChild(textElement);
            textElements.push(textElement);
            updateStatus('Text added - tap to edit, drag to move, use handles to resize/rotate');
            
            setTimeout(() => {
                selectElement(textElement);
            }, 100);
        }

        function selectElement(element) {
            document.querySelectorAll('.text-overlay, .image-overlay').forEach(el => {
                el.classList.remove('selected');
            });
            
            element.classList.add('selected');
            selectedElement = element;
        }

        function setupOverlayEvents(element, type) {
            let lastTouchTime = 0;
            
            element.addEventListener('touchstart', function(e) {
                const currentTime = new Date().getTime();
                const tapLength = currentTime - lastTouchTime;
                
                if (tapLength < 300 && tapLength > 0) {
                    if (!e.target.classList.contains('text-content')) {
                        e.preventDefault();
                        deleteElement(element, type);
                    }
                }
                lastTouchTime = currentTime;
            });
            
            element.addEventListener('dblclick', function(e) {
                if (e.target.classList.contains('text-content')) return;
                e.stopPropagation();
                deleteElement(element, type);
            });
            
            element.addEventListener('click', function(e) {
                e.stopPropagation();
                selectElement(element);
            });
        }

        function deleteElement(element, type) {
            element.remove();
            if (type === 'text') {
                textElements = textElements.filter(el => el !== element);
            } else {
                imageOverlays = imageOverlays.filter(el => el !== element);
            }
            selectedElement = null;
            updateStatus(`${type} element deleted`);
        }

        function handleGlobalMouseDown(e) {
            const coords = getCoords(e);

            if (e.type === 'touchstart') {
                const isTargetOverlay = e.target.closest('.text-overlay, .image-overlay');
                if (isTargetOverlay && !e.target.closest('.text-content')) {
                    e.preventDefault(); 
                } else if (e.target.closest('.text-content')) {
                    return;
                }
            }
            
            if (e.target.closest('.text-content')) {
                if (selectedElement && selectedElement.contains(e.target)) return;
            }

            const overlay = e.target.closest('.text-overlay, .image-overlay');
            
            if (!overlay) {
                document.querySelectorAll('.text-overlay, .image-overlay').forEach(el => {
                    el.classList.remove('selected');
                });
                selectedElement = null;
                return;
            }
            
            selectElement(overlay);
            
            if (e.target.classList.contains('resize-handle')) {
                dragState.isResizing = true;
                dragState.handle = e.target.classList[1];
                dragState.startX = coords.clientX;
                dragState.startY = coords.clientY;
                dragState.startWidth = parseFloat(overlay.style.width) || overlay.offsetWidth;
                dragState.startHeight = parseFloat(overlay.style.height) || overlay.offsetHeight;
            } else if (e.target.classList.contains('rotate-handle')) {
                dragState.isRotating = true;
                dragState.startX = coords.clientX;
                dragState.startY = coords.clientY;
                const rect = overlay.getBoundingClientRect();
                dragState.centerX = rect.left + rect.width / 2;
                dragState.centerY = rect.top + rect.height / 2;
                dragState.startRotation = getCurrentRotation(overlay);
            } else if (overlay.contains(e.target) && !e.target.classList.contains('text-content')) {
                dragState.isDragging = true;
                dragState.startX = coords.clientX - (parseFloat(overlay.style.left) || 0);
                dragState.startY = coords.clientY - (parseFloat(overlay.style.top) || 0);
            }
        }

        function handleGlobalMouseMove(e) {
            if (e.type === 'touchmove') {
                if (dragState.isDragging || dragState.isResizing || dragState.isRotating) {
                    e.preventDefault(); 
                }
            }
            
            if (!selectedElement) return;
            
            const coords = getCoords(e);
            
            if (dragState.isDragging) {
                const newX = coords.clientX - dragState.startX;
                const newY = coords.clientY - dragState.startY;
                
                const canvasRect = canvas.getBoundingClientRect();
                const overlayWidth = selectedElement.offsetWidth;
                const overlayHeight = selectedElement.offsetHeight;

                const minLeft = CANVAS_CONTAINER_PADDING;
                const minTop = CANVAS_CONTAINER_PADDING;
                
                const maxLeft = CANVAS_CONTAINER_PADDING + canvasRect.width - overlayWidth;
                const maxTop = CANVAS_CONTAINER_PADDING + canvasRect.height - overlayHeight;

                selectedElement.style.left = Math.max(minLeft, Math.min(newX, maxLeft)) + 'px';
                selectedElement.style.top = Math.max(minTop, Math.min(newY, maxTop)) + 'px';
                
            } else if (dragState.isResizing) {
                const deltaX = coords.clientX - dragState.startX;
                const deltaY = coords.clientY - dragState.startY;
                
                let newWidth = dragState.startWidth;
                let newHeight = dragState.startHeight;
                
                const currentLeft = parseFloat(selectedElement.style.left) || 0;
                const currentTop = parseFloat(selectedElement.style.top) || 0;

                if (dragState.handle.includes('e')) newWidth += deltaX;
                if (dragState.handle.includes('w')) {
                    newWidth -= deltaX;
                    selectedElement.style.left = (currentLeft + deltaX) + 'px';
                }
                if (dragState.handle.includes('s')) newHeight += deltaY;
                if (dragState.handle.includes('n')) {
                    newHeight -= deltaY;
                    selectedElement.style.top = (currentTop + deltaY) + 'px';
                }
                
                newWidth = Math.max(30, newWidth);
                newHeight = Math.max(20, newHeight);
                
                selectedElement.style.width = newWidth + 'px';
                selectedElement.style.height = newHeight + 'px';
                
                if (selectedElement.classList.contains('text-overlay')) {
                    const ratio = newHeight / dragState.startHeight;
                    const currentFontSize = parseFloat(selectedElement.style.fontSize) || 24;
                    const finalFontSize = Math.max(8, currentFontSize * ratio);
                    
                    selectedElement.style.fontSize = finalFontSize + 'px';
                    
                    updateControlsText(selectedElement, Math.round(finalFontSize) + 'px', getCurrentRotation(selectedElement));
                    
                    dragState.startWidth = newWidth;
                    dragState.startHeight = newHeight;
                    dragState.startX = coords.clientX;
                    dragState.startY = coords.clientY;
                    
                } else {
                    updateControlsText(selectedElement, `${Math.round(newWidth)}×${Math.round(newHeight)}`, getCurrentRotation(selectedElement));
                }
                
            } else if (dragState.isRotating) {
                const angle = Math.atan2(coords.clientY - dragState.centerY, coords.clientX - dragState.centerX);
                const rotation = (angle * 180 / Math.PI) + 90;
                const newRotation = Math.round(rotation / 5) * 5;
                
                selectedElement.style.transform = `rotate(${newRotation}deg)`;
                
                const sizeText = selectedElement.classList.contains('text-overlay') ? 
                    Math.round(parseFloat(selectedElement.style.fontSize || 24)) + 'px' :
                    `${Math.round(parseFloat(selectedElement.style.width))}×${Math.round(parseFloat(selectedElement.style.height))}`;
                    
                updateControlsText(selectedElement, sizeText, newRotation);
            }
        }

        function handleGlobalMouseUp() {
            dragState.isDragging = false;
            dragState.isResizing = false;
            dragState.isRotating = false;
            dragState.handle = null;
        }

        function getCurrentRotation(element) {
            const transform = element.style.transform;
            const match = transform.match(/rotate\((-?\d+)deg\)/);
            return match ? parseInt(match[1]) : 0;
        }

        function updateControlsText(element, size, rotation) {
            const controls = element.querySelector('.overlay-controls');
            if (controls) {
                controls.innerHTML = `Size: ${size} | Rotation: ${rotation}° | Press Delete to remove`;
            }
        }

        function clearOverlays() {
            textElements.forEach(overlay => overlay.remove());
            imageOverlays.forEach(overlay => overlay.remove());
            textElements = [];
            imageOverlays = [];
            selectedElement = null;
            updateStatus('All overlays cleared');
        }

        function saveToUndoStack() {
            if (canvas.width > 0 && canvas.height > 0) {
                 if (undoStack.length > 10) undoStack.shift();
                 const currentData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                 const dataCopy = ctx.createImageData(currentData.width, currentData.height);
                 dataCopy.data.set(currentData.data);
                 undoStack.push(dataCopy);
            }
        }

        function undoLastAction() {
            if (undoStack.length > 1) {
                undoStack.pop();
                ctx.putImageData(undoStack[undoStack.length - 1], 0, 0);
                updateStatus('Action undone (Ctrl+Z)');
            } else {
                updateStatus('Nothing to undo');
            }
        }

        function resetImage() {
            if (originalImageData) {
                ctx.putImageData(originalImageData, 0, 0);
                clearOverlays();
                undoStack = [];
                saveToUndoStack();
                generatePixelatedVersion();
                updateStatus('Image reset to original');
            }
        }

        function downloadImage() {
            generateFinalImage('png');
        }

        function saveAsJPEG() {
            generateFinalImage('jpeg');
        }

        function generateFinalImage(format) {
            updateStatus('Generating final image...');
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            if (format === 'jpeg') {
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            }
            
            tempCtx.drawImage(canvas, 0, 0);
            
            const displayedCanvasWidth = canvas.offsetWidth;
            const displayedCanvasHeight = canvas.offsetHeight;
            const scaleX = canvas.width / displayedCanvasWidth;
            const scaleY = canvas.height / displayedCanvasHeight;
            
            const overlays = [...imageOverlays, ...textElements];
            
            overlays.forEach(overlay => {
                try {
                    if (!overlay.style) return;
                    
                    const left = parseFloat(overlay.style.left) || 0;
                    const top = parseFloat(overlay.style.top) || 0;
                    const width = parseFloat(overlay.style.width) || overlay.offsetWidth;
                    const height = parseFloat(overlay.style.height) || overlay.offsetHeight;
                    const rotation = getCurrentRotation(overlay);
                    
                    const canvasRelativeLeft = left - CANVAS_CONTAINER_PADDING;
                    const canvasRelativeTop = top - CANVAS_CONTAINER_PADDING;

                    const scaledX = canvasRelativeLeft * scaleX; 
                    const scaledY = canvasRelativeTop * scaleY;   
                    const scaledWidth = width * scaleX;
                    const scaledHeight = height * scaleY;
                    
                    tempCtx.save();
                    
                    tempCtx.translate(scaledX + scaledWidth / 2, scaledY + scaledHeight / 2);
                    tempCtx.rotate(rotation * Math.PI / 180);
                    
                    if (overlay.classList.contains('image-overlay')) {
                        const img = overlay.querySelector('img');
                        if (!img) return;
                        tempCtx.drawImage(img, -scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
                        
                    } else if (overlay.classList.contains('text-overlay')) {
                        const textContent = overlay.querySelector('.text-content');
                        if (!textContent) return;
                        
                        if (overlay.style.backgroundColor && overlay.style.backgroundColor !== 'transparent' && scaledWidth > 0 && scaledHeight > 0) {
                            tempCtx.fillStyle = overlay.style.backgroundColor;
                            tempCtx.fillRect(-scaledWidth / 2, -scaledHeight / 2, scaledWidth, scaledHeight);
                        }
                        
                        const computedStyle = window.getComputedStyle(overlay);
                        
                        const baseFontSize = parseFloat(computedStyle.fontSize) || 24;
                        const fontSize = baseFontSize * Math.min(scaleX, scaleY);
                        
                        const fontWeight = computedStyle.fontWeight || 'normal';
                        const fontStyle = computedStyle.fontStyle || 'normal';
                        const fontFamily = computedStyle.fontFamily || 'Arial';
                        const color = computedStyle.color || '#000000';
                        
                        tempCtx.fillStyle = color;
                        tempCtx.font = `${fontStyle} ${fontWeight} ${fontSize}px "${fontFamily}"`;
                        tempCtx.textAlign = 'center';
                        tempCtx.textBaseline = 'middle';
                        
                        const text = textContent.textContent || textContent.innerText || '';
                        const lines = text.split('\n');
                        const lineHeight = fontSize * 1.2;
                        const startY = -(lines.length - 1) * lineHeight / 2;
                        
                        lines.forEach((line, index) => {
                            if (line.trim()) {
                                tempCtx.fillText(line, 0, startY + index * lineHeight);
                            }
                        });
                    }
                    
                    tempCtx.restore();
                } catch (e) {
                    console.warn('Error rendering overlay:', e);
                }
            });
            
            try {
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                const extension = format === 'jpeg' ? 'jpg' : 'png';
                link.download = `edited-image-${timestamp}.${extension}`;
                
                const quality = format === 'jpeg' ? 0.92 : undefined;
                link.href = tempCanvas.toDataURL(`image/${format}`, quality);
                link.click();
                
                updateStatus(`Image downloaded as ${extension.toUpperCase()} (Ctrl+S)`);
            } catch (e) {
                console.error('Error downloading image:', e);
                updateStatus('Error downloading image - please try again');
            }
        }

        function updateBrushSize() {
            const size = document.getElementById('brushSize').value;
            document.getElementById('brushSizeDisplay').textContent = size;
        }

        function updateStrength() {
            const strength = document.getElementById('effectStrength').value;
            document.getElementById('strengthDisplay').textContent = strength;
            
            if (currentTool === 'pixelate' && originalImageData) {
                generatePixelatedVersion();
            }
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
            
            if (!message.toLowerCase().includes('error')) {
                setTimeout(() => {
                    if (document.getElementById('statusText').textContent === message) {
                        document.getElementById('statusText').textContent = 'Ready to edit';
                    }
                }, 5000);
            }
        }

        function updateImageInfo(width, height) {
            const sizeInMB = ((width * height * 4) / (1024 * 1024)).toFixed(2);
            document.getElementById('imageInfo').textContent = `${width} × ${height} pixels (${sizeInMB} MB)`;
        }

        setTool('pixelate');
        
        setTimeout(() => {
            if (!canvas.width) {
                updateStatus('Tip: Try uploading an image to start editing, or use Ctrl+Z to undo actions');
            }
        }, 3000);
    </script>
</body>
</html>
