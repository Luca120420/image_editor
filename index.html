<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Image Editor</title>
Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
Â  Â  <style>
Â  Â  Â  Â  :root {
Â  Â  Â  Â  Â  Â  --bg-dark: #121212;
Â  Â  Â  Â  Â  Â  --panel-bg: #1e1e1e;
Â  Â  Â  Â  Â  Â  --text-main: #e0e0e0;
Â  Â  Â  Â  Â  Â  --accent: #6366f1;
Â  Â  Â  Â  Â  Â  --border: #333;
Â  Â  Â  Â  }

Â  Â  Â  Â  body {
Â  Â  Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  height: 100vh;
Â  Â  Â  Â  Â  Â  background-color: var(--bg-dark);
Â  Â  Â  Â  Â  Â  color: var(--text-main);
Â  Â  Â  Â  Â  Â  font-family: 'Inter', system-ui, sans-serif;
Â  Â  Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- LAYOUT --- */
Â  Â  Â  Â  .sidebar, .right-sidebar {
Â  Â  Â  Â  Â  Â  width: 260px;
Â  Â  Â  Â  Â  Â  background-color: var(--panel-bg);
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  gap: 15px;
Â  Â  Â  Â  Â  Â  overflow-y: auto;
Â  Â  Â  Â  Â  Â  z-index: 10;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 10px rgba(0,0,0,0.5);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .sidebar { border-right: 1px solid var(--border); }
Â  Â  Â  Â  .right-sidebar { border-left: 1px solid var(--border); }

Â  Â  Â  Â  .workspace {
Â  Â  Â  Â  Â  Â  flex: 1;
Â  Â  Â  Â  Â  Â  /* Changed background to a slightly lighter dark gray to contrast with the shadow */
Â  Â  Â  Â  Â  Â  background-color: #1a1a1a;Â 
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  overflow: hidden;Â 
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  }

Â  Â  Â  Â  /* --- NEW: Make the canvas stand out --- */
Â  Â  Â  Â  /* Fabric.js wraps the actual canvas tag in a wrapper class called .canvas-container */
Â  Â  Â  Â  .canvas-container {
Â  Â  Â  Â  Â  Â  /* Add a strong shadow to make it lift off the page */
Â  Â  Â  Â  Â  Â  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
Â  Â  Â  Â  Â  Â  /* Optional: A very subtle border */
Â  Â  Â  Â  Â  Â  border: 1px solid #333;
Â  Â  Â  Â  }


Â  Â  Â  Â  /* --- UI ELEMENTS --- */
Â  Â  Â  Â  h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; color: #888; }
Â  Â  Â  Â Â 
Â  Â  Â  Â  button, .btn-upload {
Â  Â  Â  Â  Â  Â  background-color: #333;
Â  Â  Â  Â  Â  Â  color: white;
Â  Â  Â  Â  Â  Â  border: 1px solid #444;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  border-radius: 6px;
Â  Â  Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  Â  Â  font-size: 13px;
Â  Â  Â  Â  Â  Â  transition: all 0.2s;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  margin-bottom: 5px;
Â  Â  Â  Â  }

Â  Â  Â  Â  button:hover { background-color: var(--accent); border-color: var(--accent); }
Â  Â  Â  Â  button:disabled { opacity: 0.5; cursor: not-allowed; }

Â  Â  Â  Â  .row { display: flex; gap: 5px; }
Â  Â  Â  Â  .row input { width: 50%; background: #333; border: 1px solid #444; color: white; padding: 5px; border-radius: 4px; }

Â  Â  Â  Â  input[type="range"] { width: 100%; accent-color: var(--accent); margin: 10px 0; }
Â  Â  Â  Â  input[type="file"] { display: none; }

Â  Â  Â  Â  /* Crop Mode Overlay */
Â  Â  Â  Â  #crop-controls {
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  background: #2a2a2a;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  border: 1px solid var(--accent);
Â  Â  Â  Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  .controls-info {
Â  Â  Â  Â  Â  Â  font-size: 11px;
Â  Â  Â  Â  Â  Â  color: #666;
Â  Â  Â  Â  Â  Â  margin-top: auto;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding-top: 20px;
Â  Â  Â  Â  }

Â  Â  </style>
</head>
<body>

Â  Â  <div class="sidebar">
Â  Â  Â  Â  <h3>File</h3>
Â  Â  Â  Â  <label for="imgLoader" class="btn-upload">ğŸ“‚ Upload Image</label>
Â  Â  Â  Â  <input type="file" id="imgLoader" accept="image/*">
Â  Â  Â  Â  <button onclick="downloadImage()" style="background-color: #059669;">ğŸ’¾ Export Image</button>

Â  Â  Â  Â  <h3>Canvas Size</h3>
Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  <input type="number" id="canvas-w" placeholder="W">
Â  Â  Â  Â  Â  Â  <input type="number" id="canvas-h" placeholder="H">
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <button onclick="resizeCanvasManual()">Resize Canvas</button>

Â  Â  Â  Â  <h3>History</h3>
Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  <button onclick="undo()">â†© Undo</button>
Â  Â  Â  Â  Â  Â  <button onclick="redo()">â†ª Redo</button>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <h3>Tools</h3>
Â  Â  Â  Â  <button onclick="toggleCropMode()">âœ‚ï¸ Crop Image</button>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <div id="crop-controls">
Â  Â  Â  Â  Â  Â  <p style="font-size: 12px; margin:0 0 5px 0;">Adjust the box then click Apply</p>
Â  Â  Â  Â  Â  Â  <div class="row">
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="applyCrop()" style="background-color: var(--accent);">âœ… Apply</button>
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="cancelCrop()" style="background-color: #ef4444;">âŒ Cancel</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>

Â  Â  Â  Â  <button onclick="addText()">Aa Add Text</button>
Â  Â  Â  Â  <button onclick="deleteObject()" style="background-color: #ef4444;">ğŸ—‘ï¸ Delete Selected</button>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <button onclick="resetZoom()">ğŸ” Reset Zoom (100%)</button>

Â  Â  Â  Â  <div class="controls-info">
Â  Â  Â  Â  Â  Â  ğŸ–±ï¸ <b>Scroll</b> to Zoom<br>
Â  Â  Â  Â  Â  Â  âŒ¨ï¸ <b>Alt + Drag</b> to Pan
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div class="workspace" id="workspace-container">
Â  Â  Â  Â  <canvas id="c"></canvas>
Â  Â  </div>

Â  Â  <div class="right-sidebar">
Â  Â  Â  Â  <h3>Effects</h3>
Â  Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  Â  Â  <label>Opacity</label>
Â  Â  Â  Â  Â  Â  <input type="range" id="opacity-slider" min="0" max="1" step="0.05" value="1" oninput="changeOpacity()">
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  Â  Â  <label>Blur</label>
Â  Â  Â  Â  Â  Â  <input type="range" id="blur-slider" min="0" max="1" step="0.05" value="0" oninput="applyBlur()">
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  Â  Â  <label>Pixelate</label>
Â  Â  Â  Â  Â  Â  <input type="range" id="pixel-slider" min="1" max="20" step="1" value="1" oninput="applyPixelate()">
Â  Â  Â  Â  </div>
Â  Â  Â  Â Â 
Â  Â  Â  Â  <h3>Layers</h3>
Â  Â  Â  Â  <button onclick="sendBack()">â¬‡ï¸ Send Backwards</button>
Â  Â  Â  Â  <button onclick="bringFront()">â¬†ï¸ Bring Forward</button>
Â  Â  </div>

Â  Â  <script>
Â  Â  Â  Â  // --- 1. INITIALIZATION & HISTORY ---
Â  Â  Â  Â  const canvas = new fabric.Canvas('c', {
Â  Â  Â  Â  Â  Â  // Changed background color to WHITE for high contrast
Â  Â  Â  Â  Â  Â  backgroundColor: '#5d5d5d',Â 
Â  Â  Â  Â  Â  Â  preserveObjectStacking: true,
Â  Â  Â  Â  Â  Â  selection: true
Â  Â  Â  Â  });

Â  Â  Â  Â  // Set initial workspace size
Â  Â  Â  Â  const workspaceEl = document.getElementById('workspace-container');
Â  Â  Â  Â  // Initial fit to screen
Â  Â  Â  Â  canvas.setDimensions({ width: workspaceEl.clientWidth * 0.8, height: workspaceEl.clientHeight * 0.8 });
Â  Â  Â  Â  // Center the canvas initially
Â  Â  Â  Â  workspaceEl.scrollTo((workspaceEl.scrollWidth - workspaceEl.clientWidth) / 2, (workspaceEl.scrollHeight - workspaceEl.clientHeight) / 2);
Â  Â  Â  Â  updateCanvasInputs();

Â  Â  Â  Â  // History State
Â  Â  Â  Â  let history = [];
Â  Â  Â  Â  let historyProcessing = false;
Â  Â  Â  Â  let mods = -1;

Â  Â  Â  Â  saveHistory();

Â  Â  Â  Â  function saveHistory() {
Â  Â  Â  Â  Â  Â  if (historyProcessing) return;
Â  Â  Â  Â  Â  Â  if (mods < history.length - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  history = history.slice(0, mods + 1);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  history.push(JSON.stringify(canvas));
Â  Â  Â  Â  Â  Â  mods++;
Â  Â  Â  Â  }

Â  Â  Â  Â  canvas.on('object:modified', saveHistory);
Â  Â  Â  Â  canvas.on('object:added', (e) => {Â 
Â  Â  Â  Â  Â  Â  if(!historyProcessing && e.target.type !== 'line') saveHistory()Â 
Â  Â  Â  Â  });
Â  Â  Â  Â  canvas.on('object:removed', (e) => {Â 
Â  Â  Â  Â  Â  Â  if(!historyProcessing && e.target.type !== 'line') saveHistory()Â 
Â  Â  Â  Â  });

Â  Â  Â  Â  function undo() {
Â  Â  Â  Â  Â  Â  if (mods > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  historyProcessing = true;
Â  Â  Â  Â  Â  Â  Â  Â  mods--;
Â  Â  Â  Â  Â  Â  Â  Â  canvas.loadFromJSON(history[mods], function() {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  historyProcessing = false;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function redo() {
Â  Â  Â  Â  Â  Â  if (mods < history.length - 1) {
Â  Â  Â  Â  Â  Â  Â  Â  historyProcessing = true;
Â  Â  Â  Â  Â  Â  Â  Â  mods++;
Â  Â  Â  Â  Â  Â  Â  Â  canvas.loadFromJSON(history[mods], function() {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  historyProcessing = false;
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  document.addEventListener('keydown', function(e) {
Â  Â  Â  Â  Â  Â  if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
Â  Â  Â  Â  Â  Â  Â  Â  e.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  undo();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });


Â  Â  Â  Â  // --- 2. UPLOAD & AUTO-LAYOUT ---
Â  Â  Â  Â  document.getElementById('imgLoader').addEventListener('change', function(e) {
Â  Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  Â  reader.onload = function(event) {
Â  Â  Â  Â  Â  Â  Â  Â  const imgObj = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  imgObj.src = event.target.result;
Â  Â  Â  Â  Â  Â  Â  Â  imgObj.onload = function() {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const imgInstance = new fabric.Image(imgObj);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // If first upload, resize canvas to fit image (with some padding)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (canvas.getObjects().length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // Optional: Resize canvas to fit the first image texture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // canvas.setDimensions({ width: imgInstance.width, height: imgInstance.height });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // updateCanvasInputs();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (imgInstance.width > canvas.width) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imgInstance.scaleToWidth(canvas.width * 0.8);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.add(imgInstance);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.centerObject(imgInstance);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  imgInstance.setCoords();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.setActiveObject(imgInstance);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  saveHistory();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  reader.readAsDataURL(e.target.files[0]);
Â  Â  Â  Â  Â  Â  e.target.value = '';Â 
Â  Â  Â  Â  });

Â  Â  Â  Â  // --- 3. CANVAS RESIZE ---
Â  Â  Â  Â  function updateCanvasInputs() {
Â  Â  Â  Â  Â  Â  document.getElementById('canvas-w').value = canvas.width;
Â  Â  Â  Â  Â  Â  document.getElementById('canvas-h').value = canvas.height;
Â  Â  Â  Â  }

Â  Â  Â  Â  function resizeCanvasManual() {
Â  Â  Â  Â  Â  Â  const w = parseInt(document.getElementById('canvas-w').value);
Â  Â  Â  Â  Â  Â  const h = parseInt(document.getElementById('canvas-h').value);
Â  Â  Â  Â  Â  Â  canvas.setDimensions({ width: w, height: h });
Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  Â  Â  saveHistory();
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- 4. ZOOM & PAN SYSTEM ---
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Mouse Wheel Zoom
Â  Â  Â  Â  canvas.on('mouse:wheel', function(opt) {
Â  Â  Â  Â  Â  Â  const delta = opt.e.deltaY;
Â  Â  Â  Â  Â  Â  let zoom = canvas.getZoom();
Â  Â  Â  Â  Â  Â  zoom *= 0.999 ** delta;
Â  Â  Â  Â  Â  Â  if (zoom > 20) zoom = 20;
Â  Â  Â  Â  Â  Â  if (zoom < 0.1) zoom = 0.1;
Â  Â  Â  Â  Â  Â  canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
Â  Â  Â  Â  Â  Â  opt.e.preventDefault();
Â  Â  Â  Â  Â  Â  opt.e.stopPropagation();
Â  Â  Â  Â  });

Â  Â  Â  Â  // Panning (Alt + Drag)
Â  Â  Â  Â  let isDragging = false;
Â  Â  Â  Â  let lastPosX;
Â  Â  Â  Â  let lastPosY;

Â  Â  Â  Â  canvas.on('mouse:down', function(opt) {
Â  Â  Â  Â  Â  Â  const evt = opt.e;
Â  Â  Â  Â  Â  Â  if (evt.altKey === true) {
Â  Â  Â  Â  Â  Â  Â  Â  isDragging = true;
Â  Â  Â  Â  Â  Â  Â  Â  this.selection = false;
Â  Â  Â  Â  Â  Â  Â  Â  lastPosX = evt.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  lastPosY = evt.clientY;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  canvas.on('mouse:move', function(opt) {
Â  Â  Â  Â  Â  Â  if (this.isDragging) {
Â  Â  Â  Â  Â  Â  Â  Â  const e = opt.e;
Â  Â  Â  Â  Â  Â  Â  Â  const vpt = this.viewportTransform;
Â  Â  Â  Â  Â  Â  Â  Â  vpt[4] += e.clientX - lastPosX;
Â  Â  Â  Â  Â  Â  Â  Â  vpt[5] += e.clientY - lastPosY;
Â  Â  Â  Â  Â  Â  Â  Â  this.requestRenderAll();
Â  Â  Â  Â  Â  Â  Â  Â  lastPosX = e.clientX;
Â  Â  Â  Â  Â  Â  Â  Â  lastPosY = e.clientY;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  canvas.on('mouse:up', function(opt) {
Â  Â  Â  Â  Â  Â  this.setViewportTransform(this.viewportTransform);
Â  Â  Â  Â  Â  Â  this.isDragging = false;
Â  Â  Â  Â  Â  Â  this.selection = true;
Â  Â  Â  Â  });

Â  Â  Â  Â  function resetZoom() {
Â  Â  Â  Â  Â  Â  canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- 5. ADVANCED MAGNET / SNAPPING ---
Â  Â  Â  Â Â 
Â  Â  Â  Â  canvas.on('object:moving', function (e) {
Â  Â  Â  Â  Â  Â  const obj = e.target;
Â  Â  Â  Â  Â  Â  const snapRange = 10;Â 
Â  Â  Â  Â  Â  Â  clearGuideLines();

Â  Â  Â  Â  Â  Â  let snappedV = false;
Â  Â  Â  Â  Â  Â  let snappedH = false;
Â  Â  Â  Â  Â  Â  const canvasWidth = canvas.width;
Â  Â  Â  Â  Â  Â  const canvasHeight = canvas.height;

Â  Â  Â  Â  Â  Â  const objRect = obj.getBoundingRect(true);Â 
Â  Â  Â  Â  Â  Â  const objCenterX = objRect.left + objRect.width / 2;
Â  Â  Â  Â  Â  Â  const objCenterY = objRect.top + objRect.height / 2;

Â  Â  Â  Â  Â  Â  // --- Canvas Border Snapping ---
Â  Â  Â  Â  Â  Â  if (Math.abs(objRect.left) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: 0 + (obj.left - objRect.left) });Â 
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, 0, 0, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  } else if (Math.abs(objRect.left + objRect.width - canvasWidth) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: canvasWidth - objRect.width + (obj.left - objRect.left) });
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(canvasWidth, 0, canvasWidth, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  } else if (Math.abs(objCenterX - canvasWidth / 2) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: canvasWidth / 2 - (objCenterX - obj.left) });
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(canvasWidth / 2, 0, canvasWidth / 2, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (Math.abs(objRect.top) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ top: 0 + (obj.top - objRect.top) });
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, 0, canvasWidth, 0);
Â  Â  Â  Â  Â  Â  Â  Â  snappedH = true;
Â  Â  Â  Â  Â  Â  } else if (Math.abs(objRect.top + objRect.height - canvasHeight) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ top: canvasHeight - objRect.height + (obj.top - objRect.top) });
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, canvasHeight, canvasWidth, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  snappedH = true;
Â  Â  Â  Â  Â  Â  } else if (Math.abs(objCenterY - canvasHeight / 2) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ top: canvasHeight / 2 - (objCenterY - obj.top) });
Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, canvasHeight / 2, canvasWidth, canvasHeight / 2);
Â  Â  Â  Â  Â  Â  Â  Â  snappedH = true;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // --- Object to Object Snapping ---
Â  Â  Â  Â  Â  Â  if (!snappedV || !snappedH) {
Â  Â  Â  Â  Â  Â  Â  Â  canvas.getObjects().forEach(target => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target === obj || target.type === 'line' || target.type === 'rect' && target.excludeFromSnapping) return;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetRect = target.getBoundingRect(true);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetCenterX = targetRect.left + targetRect.width / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const targetCenterY = targetRect.top + targetRect.height / 2;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!snappedV) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(objRect.left - targetRect.left) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: targetRect.left + (obj.left - objRect.left) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(targetRect.left, 0, targetRect.left, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (Math.abs(objRect.left - (targetRect.left + targetRect.width)) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: targetRect.left + targetRect.width + (obj.left - objRect.left) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(targetRect.left + targetRect.width, 0, targetRect.left + targetRect.width, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (Math.abs((objRect.left + objRect.width) - (targetRect.left + targetRect.width)) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â obj.set({ left: targetRect.left + targetRect.width - objRect.width + (obj.left - objRect.left) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â drawGuideLine(targetRect.left + targetRect.width, 0, targetRect.left + targetRect.width, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â snappedV = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (Math.abs(objCenterX - targetCenterX) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ left: targetCenterX - (objCenterX - obj.left) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(targetCenterX, 0, targetCenterX, canvasHeight);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  snappedV = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!snappedH) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.abs(objRect.top - targetRect.top) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ top: targetRect.top + (obj.top - objRect.top) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, targetRect.top, canvasWidth, targetRect.top);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  snappedH = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (Math.abs((objRect.top + objRect.height) - (targetRect.top + targetRect.height)) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â obj.set({ top: targetRect.top + targetRect.height - objRect.height + (obj.top - objRect.top) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â drawGuideLine(0, targetRect.top + targetRect.height, canvasWidth, targetRect.top + targetRect.height);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â snappedH = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (Math.abs(objCenterY - targetCenterY) < snapRange) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  obj.set({ top: targetCenterY - (objCenterY - obj.top) });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawGuideLine(0, targetCenterY, canvasWidth, targetCenterY);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  snappedH = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });

Â  Â  Â  Â  canvas.on('object:modified', clearGuideLines);
Â  Â  Â  Â  canvas.on('mouse:up', clearGuideLines);

Â  Â  Â  Â  let guideLines = [];
Â  Â  Â  Â  function drawGuideLine(x1, y1, x2, y2) {
Â  Â  Â  Â  Â  Â  const line = new fabric.Line([x1, y1, x2, y2], {
Â  Â  Â  Â  Â  Â  Â  Â  stroke: '#00d2ff',
Â  Â  Â  Â  Â  Â  Â  Â  strokeWidth: 1,
Â  Â  Â  Â  Â  Â  Â  Â  selectable: false,
Â  Â  Â  Â  Â  Â  Â  Â  evented: false,
Â  Â  Â  Â  Â  Â  Â  Â  strokeDashArray: [5, 5],
Â  Â  Â  Â  Â  Â  Â  Â  opacity: 0.8
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  canvas.add(line);
Â  Â  Â  Â  Â  Â  guideLines.push(line);
Â  Â  Â  Â  }

Â  Â  Â  Â  function clearGuideLines() {
Â  Â  Â  Â  Â  Â  guideLines.forEach(line => canvas.remove(line));
Â  Â  Â  Â  Â  Â  guideLines = [];
Â  Â  Â  Â  }


Â  Â  Â  Â  // --- 6. CROP SYSTEM ---
Â  Â  Â  Â  let cropRect = null;
Â  Â  Â  Â  let imageToCrop = null;

Â  Â  Â  Â  function toggleCropMode() {
Â  Â  Â  Â  Â  Â  resetZoom();Â 

Â  Â  Â  Â  Â  Â  const activeObj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if (!activeObj || activeObj.type !== 'image') {
Â  Â  Â  Â  Â  Â  Â  Â  alert("Please select an image to crop first.");
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  imageToCrop = activeObj;
Â  Â  Â  Â  Â  Â  document.getElementById('crop-controls').style.display = 'block';

Â  Â  Â  Â  Â  Â  cropRect = new fabric.Rect({
Â  Â  Â  Â  Â  Â  Â  Â  left: imageToCrop.left,
Â  Â  Â  Â  Â  Â  Â  Â  top: imageToCrop.top,
Â  Â  Â  Â  Â  Â  Â  Â  width: imageToCrop.getScaledWidth(),
Â  Â  Â  Â  Â  Â  Â  Â  height: imageToCrop.getScaledHeight(),
Â  Â  Â  Â  Â  Â  Â  Â  fill: 'rgba(0,0,0,0.3)',
Â  Â  Â  Â  Â  Â  Â  Â  stroke: '#6366f1',
Â  Â  Â  Â  Â  Â  Â  Â  strokeWidth: 2,
Â  Â  Â  Â  Â  Â  Â  Â  strokeDashArray: [5, 5],
Â  Â  Â  Â  Â  Â  Â  Â  cornerColor: 'white',
Â  Â  Â  Â  Â  Â  Â  Â  cornerStrokeColor: '#6366f1',
Â  Â  Â  Â  Â  Â  Â  Â  transparentCorners: false,
Â  Â  Â  Â  Â  Â  Â  Â  excludeFromSnapping: trueÂ 
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  canvas.add(cropRect);
Â  Â  Â  Â  Â  Â  canvas.setActiveObject(cropRect);
Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  }

Â  Â  Â  Â  function applyCrop() {
Â  Â  Â  Â  Â  Â  if (!cropRect || !imageToCrop) return;

Â  Â  Â  Â  Â  Â  const left = cropRect.left - imageToCrop.left;
Â  Â  Â  Â  Â  Â  const top = cropRect.top - imageToCrop.top;
Â  Â  Â  Â  Â  Â  const width = cropRect.getScaledWidth();
Â  Â  Â  Â  Â  Â  const height = cropRect.getScaledHeight();

Â  Â  Â  Â  Â  Â  cropRect.visible = false;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const croppedData = canvas.toDataURL({
Â  Â  Â  Â  Â  Â  Â  Â  left: cropRect.left,
Â  Â  Â  Â  Â  Â  Â  Â  top: cropRect.top,
Â  Â  Â  Â  Â  Â  Â  Â  width: width,
Â  Â  Â  Â  Â  Â  Â  Â  height: height,
Â  Â  Â  Â  Â  Â  Â  Â  format: 'png',
Â  Â  Â  Â  Â  Â  Â  Â  multiplier: 2
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  fabric.Image.fromURL(croppedData, function(newImg) {
Â  Â  Â  Â  Â  Â  Â  Â  newImg.set({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  left: cropRect.left,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  top: cropRect.top
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  canvas.remove(imageToCrop);
Â  Â  Â  Â  Â  Â  Â  Â  canvas.remove(cropRect);
Â  Â  Â  Â  Â  Â  Â  Â  canvas.add(newImg);
Â  Â  Â  Â  Â  Â  Â  Â  canvas.setActiveObject(newImg);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  cancelCrop();
Â  Â  Â  Â  Â  Â  Â  Â  saveHistory();
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  function cancelCrop() {
Â  Â  Â  Â  Â  Â  if (cropRect) canvas.remove(cropRect);
Â  Â  Â  Â  Â  Â  cropRect = null;
Â  Â  Â  Â  Â  Â  imageToCrop = null;
Â  Â  Â  Â  Â  Â  document.getElementById('crop-controls').style.display = 'none';
Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- 7. STANDARD TOOLS ---
Â  Â  Â  Â  function addText() {
Â  Â  Â  Â  Â  Â  const text = new fabric.IText('Type Here', {
Â  Â  Â  Â  Â  Â  Â  Â  left: canvas.width/2, top: canvas.height/2,
Â  Â  Â  Â  Â  Â  Â  Â  fontFamily: 'sans-serif', fill: '#111', fontSize: 40, originX: 'center', originY: 'center'
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  canvas.add(text);
Â  Â  Â  Â  Â  Â  canvas.setActiveObject(text);
Â  Â  Â  Â  }

Â  Â  Â  Â  function deleteObject() {
Â  Â  Â  Â  Â  Â  const active = canvas.getActiveObjects();
Â  Â  Â  Â  Â  Â  if (active.length) {
Â  Â  Â  Â  Â  Â  Â  Â  canvas.discardActiveObject();
Â  Â  Â  Â  Â  Â  Â  Â  active.forEach(obj => canvas.remove(obj));
Â  Â  Â  Â  Â  Â  Â  Â  saveHistory();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Effects
Â  Â  Â  Â  function applyBlur() {
Â  Â  Â  Â  Â  Â  const obj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if (!obj || obj.type !== 'image') return;
Â  Â  Â  Â  Â  Â  const val = parseFloat(document.getElementById('blur-slider').value);
Â  Â  Â  Â  Â  Â  obj.filters = obj.filters.filter(f => f.type !== 'Blur');
Â  Â  Â  Â  Â  Â  if (val > 0) obj.filters.push(new fabric.Image.filters.Blur({ blur: val }));
Â  Â  Â  Â  Â  Â  obj.applyFilters();
Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function applyPixelate() {
Â  Â  Â  Â  Â  Â  const obj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if (!obj || obj.type !== 'image') return;
Â  Â  Â  Â  Â  Â  const val = parseInt(document.getElementById('pixel-slider').value);
Â  Â  Â  Â  Â  Â  obj.filters = obj.filters.filter(f => f.type !== 'Pixelate');
Â  Â  Â  Â  Â  Â  if (val > 1) obj.filters.push(new fabric.Image.filters.Pixelate({ blocksize: val }));
Â  Â  Â  Â  Â  Â  obj.applyFilters();
Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  }

Â  Â  Â  Â  function changeOpacity() {
Â  Â  Â  Â  Â  Â  const obj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if(obj) {
Â  Â  Â  Â  Â  Â  Â  Â  obj.set('opacity', parseFloat(document.getElementById('opacity-slider').value));
Â  Â  Â  Â  Â  Â  Â  Â  canvas.renderAll();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function bringFront() {
Â  Â  Â  Â  Â  Â  const obj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if(obj) { obj.bringForward(); saveHistory(); }
Â  Â  Â  Â  }

Â  Â  Â  Â  function sendBack() {
Â  Â  Â  Â  Â  Â  const obj = canvas.getActiveObject();
Â  Â  Â  Â  Â  Â  if(obj) { obj.sendBackwards(); saveHistory(); }
Â  Â  Â  Â  }

Â  Â  Â  Â  function downloadImage() {
Â  Â  Â  Â  Â  Â  const vpt = canvas.viewportTransform;
Â  Â  Â  Â  Â  Â  canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const link = document.createElement('a');
Â  Â  Â  Â  Â  Â  link.download = 'edited.png';
Â  Â  Â  Â  Â  Â  link.href = canvas.toDataURL({ format: 'png', multiplier: 2 });
Â  Â  Â  Â  Â  Â  link.click();

Â  Â  Â  Â  Â  Â  canvas.setViewportTransform(vpt);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  window.addEventListener('keydown', (e) => {
Â  Â  Â  Â  Â  Â  if(e.key === 'Delete') deleteObject();
Â  Â  Â  Â  });

Â  Â  </script>
</body>
</html>
